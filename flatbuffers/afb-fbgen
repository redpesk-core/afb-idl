#!/bin/bash

# dependances :
# jq mustash flatcc
# jq remplacÃ© par un binaire ?

# template will be stored in :
# prefix/afb-idl/afb-flatbuffers/templates

# sous execs
# prefix/libexec/afbidl


corename() {
	local n="$(basename "$1")"
	echo -n "${n%.*}"
}

PROGRAM=$0
PGNAME=$(corename $0)
PGDIR=$(dirname $0)
TEMPDIR="/tmp/$PGNAME.$$"
: ${TEMPLATE_PATH:=$PWD}

usage() {
	echo "Usage :"
	echo " "
	echo "  $PROGRAM FLATBUFFERS_SCHEMA [OPTION...]"
	echo "  $PROGRAM -h | --help"
	echo " "
	echo "Options :"
	echo " "
	echo "  -c | --converter            generate a converter"
	echo "  -a | --api                  generate an api skeleton"
	echo "  -l | --client               generate an client skeleton"
	echo "  -m | --cmake                generate the CMakeLists.txt"
	echo "  -h | --help                 display help"
	echo "  -o | --out-prefix PREFIX    specify output prefix. By default output"
	echo "                              prefix is based on flatbuffer schema name"
	echo " "
	echo "Note : if no target are specified all targets are generated"
	exit 1
}

err() {
	echo "$*" >&2
	exit 1
}

declare -a TPATH
while [ -n "$TEMPLATE_PATH" ]; do
	p="${TEMPLATE_PATH%%:*}"
	TPATH+=("$p")
	[ "$p" =  "$TEMPLATE_PATH" ] && break;
	TEMPLATE_PATH="${TEMPLATE_PATH#*:}"
done
SUBPATH="afb-idl/afb-flatbuffers"
TPATH+=("$PWD" "$HOME/.config/$SUBPATH" "$PGDIR/../share/$SUBPATH" "$PGDIR")
find_template() {
	for d in "${TPATH[@]}"; do
		f="$d/$1"
		[ -f "$f" ] && { echo "$f"; return 0; }
	done
	return 1
}

header() {
	echo "/*"
	echo " * generated by $1 based on $2 as schema and $3 as template"
	echo " */"
	echo " "
}

generate() {
	# generate header
	header "$PGNAME" "$1" "$2"

	# Finaly generate the c code with mustach
	# baised on the json input file and the template
	# and put it into output file
	mustach "$1" "$2"
}

fbgen() {
	# determine what to generate
	case "$1" in
		cvt) ext=cvt; ixt=types;; # generate a convreter
		cli) ext=cli; ixt=apis;;  # generate a client
		api) ext=api; ixt=apis;;  # generate an api
		*) err "invalid call"     # otherwise return an error
	esac
	
	# Parse the output file name <ofile>-fb${ext}.<wg>
	# for example "sample-fbapi.c" will give :
	# $ofile = "sample"
	# $wg = "c"
	# NB: by default <wg> is "c"
	[ -z "$2" ] && err "no arg"
	ofile="$2"
	wg="${ofile##*.}"
	wg="${wg:-c}"
	ofile="${ofile%.*}"
	ofile="${ofile%-fb${ext}}"

	# If an input file is given in second parametter use it,
	# otherway checkout for a file based on output name suffix
	inspec="${3:-${ofile}-rpc-types.json}"

	# Return error if not found
	[ -f "$inspec" ] || err "spec $inspec not found"

	# search for a template named fd-template-<ext>.<wg> in working directory
	# then in afb-ild config directory and finaly in <executable dir>/../share/afbidl
	if ! templ=$(find_template "fb-template-$ext.$wg"); then
		# return error if no template is found
		err "template fb-template-$ext.$wg not found"
	fi

	# generate the file
	generate "$inspec" "$templ" > "$ofile-fb$ext.$wg"
}

POSITIONAL=()
declare -A param

while [[ $# -gt 0 ]]; do
	key="$1"

	case $key in
		-c|--converter)
		param[converter]=YES
		shift # past argument
		;;

		-a|--api)
		param[api]=YES
		param[converter]=YES
		shift # past argument
		;;

		-l|--client)
		param[client]=YES
		shift # past argument
		;;

		-o|--out-prefix)
		out_prefix=$2
		shift 2 # past argument
		;;

		-m|--cmake)
		param[cmake]=YES
		shift
		;;

		-h|--help)
		usage
		;;

		*)    # unknown option
		POSITIONAL+=("$1") # save it in an array for later
		shift # past argument
		;;
	esac
done

# If nothing is specified build all
if [[ ${#param[@]} -eq 0 ]]; then
	param[converter]=YES
	param[api]=YES
	param[client]=YES
	param[cmake]=YES
fi

# Get flatbuffer schema as imput
if [[ ${#POSITIONAL[@]} -eq 0 ]]; then
	echo "Flatbuffers schema is missing !"
	usage
fi

set -- "${POSITIONAL[@]}" # restore positional parameters
fbschema="$1"
fbsname="$(corename $fbschema)"
prjname="$fbsname"

# Set output prefix based on input if not specifyed with option --output-prefix
if [[ -z "$out_prefix" ]]; then 
	out_prefix="$fbsname"

# if output prefix is a directory add input name as file prefix
elif [[ "${out_prefix%/}" != "$out_prefix" ]]; then
	out_prefix+="$fbsname"
fi
outname="$(corename "$out_prefix")"

echo "selected params : ${!param[@]}"
echo "fb schema       : $fbschema"
echo "out prefix      : $out_prefix"

# check dependencies
trap "rm -r '$TEMPDIR'" EXIT
[ ! -e "$TEMPDIR" ] && mkdir -p "$TEMPDIR"
for d in "$PGDIR" "$PGDIR/../libexec" "$PGDIR/libexec"; do
	f="$d/bfbs2json"
	[ -x "$f" ] && { BFBS2JSON="$f"; break; }
done
[ -z $BFBS2JSON ] && err "required bfbs2json is unreachable"
[ -z $(which jq) ] && err "required jq is not installed"
[ -z $(which mustach) ] && err "required mostach is not installed"
[ -z $(which flatcc) ] && err "required flatcc is not installed"

###########################
# Generate intermid files #
###########################

# binary flatbuffer schema
BFBS="$TEMPDIR/$fbsname.bfbs"
flatcc --schema -o "$TEMPDIR" "$fbschema"
[ -e "$BFBS" ] || err "fail to generate binary flatbuffer schema $BFBS"

# Json description of schema
JSON_SCHEMA="$TEMPDIR/$fbsname.json"
$BFBS2JSON "$BFBS" | jq . > "$JSON_SCHEMA"
[ -e "$JSON_SCHEMA" ] || err "Fail to generate json description of schema $JSON_SCHEMA"

# Json description of rpc types
JQTYPES="[.services[].calls[]|.request,.response]|unique|{\"project_name\": \"$prjname\", types:[.[]|{typename:.name,params:[{paramname:.fields[].name}]}]}"
RPC_TYPES="$TEMPDIR/$outname-rpc-types.json"
jq "$JQTYPES" < "$JSON_SCHEMA" > "$RPC_TYPES"
[ -s "$RPC_TYPES" ] || err "Fail to generate json description of rpc types $RPC_TYPES"

# Json description of rpc apis
JQAPIS="{\"project_name\":\"$prjname\",apis:[.services[]|{apiname:.name,verbs:[.calls[]|{verbname:.name,request:.request.name,response:.response.name}]}]}"
RPC_APIS="$TEMPDIR/$outname-rpc-apis.json"
jq "$JQAPIS" < "$JSON_SCHEMA" > "$RPC_APIS"
[ -s "$RPC_APIS" ] || err "Fail to generate json description of rpc apis $RPC_APIS"

###################
# generate output #
###################

# if out directory doesn't exist create it
if [ "${out_prefix%/*}" != "$out_prefix" ]; then
	mkdir -p "${out_prefix%/*}" || err "Failed to create directory ${out_prefix%/*}"
fi

# flatcc header
echo "generating : $out_prefix-flatcc.h"
flatcc -c -a --json --outfile="$out_prefix-flatcc.h" "$fbschema"

# converter
if [[ -n "${param[converter]}" ]]; then
	echo "generating : $out_prefix-fbcvt.c"
	fbgen cvt "$out_prefix-fbcvt.c" "$RPC_TYPES"
	echo "generating : $out_prefix-fbcvt.h"
	fbgen cvt "$out_prefix-fbcvt.h" "$RPC_TYPES"
fi

# api
if [[ -n "${param[api]}" ]]; then
	echo "generating : $out_prefix-fbapi.c"
	fbgen api "$out_prefix-fbapi.c" "$RPC_APIS"
fi

# client
if [[ -n "${param[client]}" ]]; then
	echo "generating : $out_prefix-fbcli.c"
	fbgen cli "$out_prefix-fbcli.c" "$RPC_APIS"
fi

# cmake
if [[ -n "${param[cmake]}" ]]; then
	echo "generating : $(dirname "$out_prefix")/CMakeLists.txt"
	template=$(find_template fb-template-CMakeLists.txt)
	mustach $RPC_APIS $template > "$(dirname "$out_prefix")/CMakeLists.txt"
fi
