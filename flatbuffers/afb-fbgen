#!/bin/bash

# dependances :
# jq mustash flatcc
# jq remplacÃ© par un binaire ?

# template will be stored in :
# prefix/afb-idl/afb-flatbuffers/tamplates

# sous execs
# prefix/libexec/afbidl

PROGRAMME=$0
PGNAME=${PROGRAMME##*/}
PGNAME=${PGNAME%.*}
TEMP_PATH="/tmp/$PGNAME"
TEMPLATE_PATH="$(pwd)"
SUBEXEC_PATH="$(pwd)/libexec"

usage() {
	echo "Usage :"
	echo " "
	echo "  $PROGRAMME FLATBUFFERS_SCHEMA [OPTION...]"
	echo "  $PROGRAMME -h | --help"
	echo " "
	echo "Options :"
	echo " "
	echo "  -c | --converter            generate a converter"
	echo "  -a | --api                  generate an api scelet"
	echo "  -l | --client               generate an client scelet"
	echo "  -m | --cmake                generate the CMakeLists.txt"
	echo "  -h | --help                 display help"
	echo "  -o | --out-prefix PREFIX    specify output prefix. By default output"
	echo "                              prefix is based on flatbuffer schema name"
	echo " "
	echo "Note : if no target are specified all targets are generated"
	exit 1
}

err() {
	echo "$*" >&2
	exit 1
}

header() {
	echo "/*"
	echo " * generated by ${1} based on ${2} as schema and ${3} as tamplate"
	echo " */"
	echo " "
}

find_template() {
	for d in "$PWD" "$HOME/.config/afb-idl/afb-flatbuffers" "$(dirname "$PROGRAMME")/../share/afb-idl/afb-flatbuffers" "$(dirname "$0")" "${TAMPLATE_PATH}"; do
		f="${d}/${1}"
		[ -f "${f}" ] && { echo ${f}; break; }
	done
}

fbgen() {
	# determine what to generate
	case "$1" in
		cvt) ext=cvt; ixt=types;; # generate a convreter
		cli) ext=cli; ixt=apis;;  # generate a client
		api) ext=api; ixt=apis;;  # generate an api
		*) err "invalid call"     # otherwaiy return an error
	esac
	
	# Parse the output file name <ofile>-fb${ext}.<wg>
	# for example "sample-fbapi.c" will give :
	# $ofile = "sample"
	# $wg = "c"
	# NB: by default <wg> is "c"
	[ -z "${2}" ] && err "no arg"
	ofile="${2}"
	wg="${ofile##*.}"
	wg="${wg:-c}"
	ofile="${ofile%.*}"
	ofile="${ofile%-fb${ext}}"

	# If an input file is given in second parametter use it,
	# otherway checkout for a file based on output name suffix
	inspec="${3:-${ofile}-rpc-types.json}"

	# Return error if not found
	[ -f "${inspec}" ] || err "spec ${inspec} not found"


	# search for a tamplate named fd-tamplate-<ext>.<wg> in working directory
	# then in afb-ild config directory and finaly in <executable dir>/../share/afbidl
	templ=$(find_template "fb-template-${ext}.${wg}")

	# return error if no tamplate is found
	[ -z "${templ}" ] && err "template fb-template-${ext}.${wg} not found"

	# generate header
	echo "$(header ${0##*/} $inspec ${templ##*/})" > "${ofile}-fb${ext}.${wg}"

	# Finaly generate the c code with mustach
	# baised on the json input file and the template
	# and put it into output file
	mustach "${inspec}" "${templ}" >> "${ofile}-fb${ext}.${wg}"
}

POSITIONAL=()

declare -A param

while [[ $# -gt 0 ]]; do
	key="$1"

	case $key in
		-c|--converter)
		param[converter]=YES
		shift # past argument
		;;

		-a|--api)
		param[api]=YES
		param[converter]=YES
		shift # past argument
		;;

		-l|--client)
		param[client]=YES
		shift # past argument
		;;

		-o|--out-prefix)
		out_prefix=$2
		shift # past argument
		shift # past argument
		;;

		-m|--cmake)
		param[cmake]=YES
		shift
		;;

		-h|--help)
		usage
		;;

		*)    # unknown option
		POSITIONAL+=("$1") # save it in an array for later
		shift # past argument
		;;
	esac
done

set -- "${POSITIONAL[@]}" # restore positional parameters

# If nothing is specifyed build all
if [[ -z ${param[@]} ]]; then
	param[converter]=YES
	param[api]=YES
	param[client]=YES
	param[cmake]=YES
fi

# Get flatbuffer schema as imput
if [[ -z "${1}" ]]; then
	echo "Flatbuffers schema is missing !"
	usage
fi
fbschema="${1}"

# Set output prefix based on input if not specifyed with option --output-prefix
if [[ -z ${out_prefix} ]]; then 
	out_prefix=${fbschema%.*}
	out_prefix=${out_prefix##*/}

# if output prefix is a directory add input name as file prefix
elif [[ ! -z ${out_prefix%/*} && -z ${out_prefix##*/} ]]; then
	out_prefix_path=${out_prefix%/*}
	out_prefix=${fbschema%.*}
	out_prefix=${out_prefix_path}/${out_prefix##*/}
fi

echo "selected params : ${!param[@]}"
echo "fb schema       : ${fbschema}"
echo "out prefix      : ${out_prefix}"

# check dependencies
[ ! -e $TEMP_PATH ] && mkdir -p $TEMP_PATH
for d in "$(dirname "$0")" "$(dirname "$0")/../libexec" "$(dirname "$0")/libexec"; do
	f="$d/bfbs2json"
	[ -x "${f}" ] && { BFBS2JSON="${f}"; break; }
done
[ -z $BFBS2JSON ] && err "required bfbs2json is unreachable"
[ -z $(which jq) ] && err "required jq is not installed"
[ -z $(which mustach) ] && err "required mostach is not installed"
[ -z $(which flatcc) ] && err "required flatcc is not installed"

###########################
# Generate intermid files #
###########################

# binary flatbuffer schema
flatcc --schema -o $TEMP_PATH $fbschema
BFBS=${fbschema%.*}.bfbs
BFBS=$TEMP_PATH/${BFBS##*/}
[ ! -e $BFBS ] && err "fail to generate binary flatbuffer schema $BFBS"

# Json description of schema
JSON_SCHEMA=$TEMP_PATH/${out_prefix##*/}.json
$BFBS2JSON $BFBS | jq . > $JSON_SCHEMA
[ ! -e $JSON_SCHEMA ] && err "Fail to generate json description of schema $JSON_SCHEMA"

# Json description of rpc types
JQTYPES='[.services[].calls[]|.request,.response]|unique|{"project_name": "'${out_prefix##*/}'", types:[.[]|{typename:.name,params:[{paramname:.fields[].name}]}]}'
RPC_TYPES=$TEMP_PATH/${out_prefix##*/}-rpc-types.json
jq "$JQTYPES" < $JSON_SCHEMA > $RPC_TYPES
[ ! -e $RPC_TYPES ] || [  ! -s $RPC_TYPES ] && err "Fail to generate json description of rpc types $RPC_TYPES"

# Json description of rpc apis
JQAPIS='{"project_name":"'${out_prefix##*/}'",apis:[.services[]|{apiname:.name,verbs:[.calls[]|{verbname:.name,request:.request.name,response:.response.name}]}]}'
RPC_APIS=$TEMP_PATH/${out_prefix##*/}-rpc-apis.json
jq "$JQAPIS" < $JSON_SCHEMA > $RPC_APIS
[ ! -e $RPC_APIS ] || [ ! -s $RPC_APIS ] && err "Fail to generate json description of rpc apis $RPC_APIS"

###################
# generate output #
###################

# if out directory doesn't exist create it
[ "${out_prefix%/*}" != "$out_prefix" ] && [ ! -e "${out_prefix%/*}" ] && mkdir -p ${out_prefix%/*}

# flatcc header
echo "generating : ${out_prefix}_flatcc.h"
flatcc -c -a --json --outfile="${out_prefix}_flatcc.h" $fbschema

# converter
if [[ -n "${param[converter]}" ]]; then
	echo "generating : $out_prefix-fbcvt.c"
	fbgen cvt "$out_prefix-fbcvt.c" $RPC_TYPES
	echo "generating : $out_prefix-fbcvt.h"
	fbgen cvt "$out_prefix-fbcvt.h" $RPC_TYPES
fi

# api
if [[ -n "${param[api]}" ]]; then
	echo "generating : $out_prefix-fbapi.c"
	fbgen api "$out_prefix-fbapi.c" $RPC_APIS
fi

# client
if [[ -n "${param[client]}" ]]; then
	echo "generating : $out_prefix-fbcli.c"
	fbgen cli "$out_prefix-fbcli.c" $RPC_APIS
fi

# cmake
if [[ -n "${param[cmake]}" ]]; then
	echo "generating : $(dirname ${out_prefix})/CMakeLists.txt"
	tamplate=$(find_template fb-template-CMakeLists.txt)
	mustach $RPC_APIS $tamplate > "$(dirname ${out_prefix})/CMakeLists.txt"
fi

echo "remove intermed files : " $TEMP_PATH/${out_prefix##*/}*
rm $TEMP_PATH/${out_prefix##*/}*